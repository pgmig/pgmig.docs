# pgmig

Разработка и сопровождение приложений в СУБД postgresql

## 1. Переводы

Этот сайт доступен на следующих языках:

* [Английский](/)
* Русский

## 2. Описание

pgmig - это технология миграций СУБД postgresql, которая включает способ организации и загрузки в БД структур данных (DDL) и хранимого кода.

Проект решает следующие задачи:
* Синхронизировать исходники в git и содержимое БД в части, которая не меняется в процессе эксплуатации (структура данных, представления, индексы, функции, триггеры, справочники и т.п.)
* Реализовать механизм тестирования хранимого кода
* Изменять БД только при успешном прохождении тестов

Для решения этих задач приняты следующие правила:

* Все, что загружается в БД, разбито на пакеты (схемы)
* Все, что меняется в процессе эксплуатации приложения, выносится в отдельные схемы БД (далее - оперативные данные)
* Чтобы гарантировать соответствие кода в git схемам неоперативных данных, перед обновлением они удаляются
* Весь SQL-код может быть разбит на файлы так, чтобы любое изменение БД можно было описать маской имен файлов, которые должны быть для него выполнены

### 2.1. Состав проекта

* [pgmig](https://github.com/pgmig/pgmig) - встраиваемая библиотека и утилита для миграции (golang)
* [pgmig.perl](https://github.com/pgmig/pgmig.perl) - порт pgmig на perl
* [`pgmig-*`](https://github.com/pgmig?q=pgmig-*) - пакеты дополнительного функционала:
  * [pkg] - управление пакетами и зависимостями
  * [testing](https://github.com/pgmig/pgmig-testing) - поддержка тестов
  * [testing-xml] - поддержка тестов для функций, которые возвращают xml
  * [rpc] - реализация RPC для проекта [apisite]()
  * [enfist] - пример хранимого кода, проект [enfist]()

## 3. Технические детали

### 3.1. Архитектура решения

Исходим из того, что есть некое приложение, использующее БД и в этой БД есть информация 2х типов:
1. оперативные данные, которые появляются в результате действий пользователей или администраторов приложения
2. все остальное, что является результатом работы программистов (и должно храниться в git)

Решение может быть в том, чтобы первое положить в отдельные схемы БД, а схемы из п.2 при обновлении БД можно было удалять.

Связи между этими схемами, которые надо учитывать:
1. Внешние ключи (некоторые справочники меняют только программисты, на них завязан код)
2. Функции, которые возвращают значение по умолчанию (использующие их поля будут удалены вместе с этими функциями)

Эти связи регистрируются в специальных таблицах, что позволяет удалять их вместе с пакетами

### 3.2. Порядок работы

Работа мигратора заключается в последовательном выполнении файлов, соответствующих маске, из заданных каталогов.
Формат вызова:
```
  pgmig [options] create|build|test|drop|erase dir...
```
Для каждой команды используются файлы заданной маски и в порядке, приведенном в таблице:

№ |Код|create|build|test|drop|erase|Описание
---|-----------|:----:|:---:|:--:|:--:|:---:|--------
00 | erase |:white_check_mark: |:white_check_mark: |:white_check_mark: |:white_check_mark: | :heavy_check_mark: | удаление защищенных объектов из других схем
01 | drop |:white_check_mark: |:white_check_mark: |:white_check_mark: | :heavy_check_mark: | :heavy_check_mark: | удаление связей текущей схемы с другими схемами, удаление текущей схемы
1x | init | :heavy_check_mark:|:white_check_mark: |:white_check_mark: |:white_check_mark: |:white_check_mark: | инициализация, создание схемы, зависимости от других пакетов
2x | common_func | :heavy_check_mark:| :heavy_check_mark:|:white_check_mark: |:white_check_mark: | :white_check_mark:| функции, не имеющие зависимостей от объектов схемы
3x | table (type) |:heavy_check_mark: | :white_check_mark:|:white_check_mark: |:white_check_mark: |:white_check_mark: | создание таблиц и типов
4x | view (view_func) |:heavy_check_mark: |:heavy_check_mark: |:white_check_mark: | :white_check_mark:|:white_check_mark: | представления и функции для них
5x | func |:heavy_check_mark: | :heavy_check_mark:| :white_check_mark:|:white_check_mark: |:white_check_mark: | основной код функций
6x | trig_func |:heavy_check_mark: |:heavy_check_mark: | :white_check_mark:| :white_check_mark:| :white_check_mark:| код триггеров
7x | trig |:heavy_check_mark: |:white_check_mark: | :white_check_mark:|:white_check_mark: |:white_check_mark: | создание триггеров
8x | data | :heavy_check_mark:|:white_check_mark: |:white_check_mark: |:white_check_mark: |:white_check_mark: |наполнение таблиц
9x | test | :heavy_check_mark:|:heavy_check_mark: |:heavy_check_mark: | :white_check_mark:| :white_check_mark:| тесты

Дополнительно
* `build` включает файлы `3*_once.sql` и `8*_once.sql`
* `recreate` состоит из выполнения `drop`, `create` и в первом этапе пакеты идут в обратном порядке

**Далее: В разработке**

## 4. История

* Первая версия этой техники была реализована в 2010 как часть проекта [PgWS](https://github.com/LeKovr/pgws)
* Второе поколение - [pomasql](https://github.com/pomasql)
* Эта документация описывает третье поколение

## 5. Авторы

* **Алексей Коврижкин** - *Идея и первичная реализация* - [LeKovr](https://github.com/LeKovr)

См. Также список [контрибьюторов](https://github.com/pomasql/poma/graphs/contributors), которые принимали участие в проекте.

## 6. Лицензия

Исходный код проектов pgmig публикуется под лицензией Apache 2.0 - см файл [LICENSE.md](https://github.com/pgmig/pgmig/blob/master/LICENSE).
