[{"content":"pgmig Разработка и сопровождение приложений в СУБД postgresql\n1. Переводы Этот сайт доступен на следующих языках:\n Английский (черновик) Русский (до релиза 1.0 - наиболее полное описание)  2. Описание pgmig - это утилита и библиотека для загрузки в БД postgresql файлов *.sql из клонированного git-репозитория (или нескольких) и последующей загрузки изменений этих файлов.\nВ проекте реализовано два способа изменения (миграции) БД:\n Загрузка только файлов с идемпотентными запросами (например, CREATE OR REPLACE FUNCTION при отсутствии изменений в сигнатуре) Загрузка всех файлов схемы БД с ее предварительным удалением  Проект решает следующие задачи:\n Синхронизировать исходники в git и содержимое БД в части, которая не меняется в процессе эксплуатации (структура данных, представления, индексы, функции, триггеры, справочники и т.п.) Реализовать механизм тестирования хранимого кода Изменять БД только при успешном прохождении тестов  Для решения этих задач приняты следующие правила:\n Все, что загружается в БД, разбито на пакеты (схемы) Все, что меняется в процессе эксплуатации приложения, выносится в отдельные схемы БД (далее - оперативные данные) Чтобы гарантировать соответствие кода в git схемам неоперативных данных, перед обновлением они удаляются Весь SQL-код разделяется на файлы так, чтобы любое изменение БД можно было описать маской имен файлов, которые должны быть для него выполнены  2.1. Состав проекта  pgmig - встраиваемая библиотека и утилита для миграции (golang) pgmig.perl - порт pgmig на perl SQL-пакеты:  pgmig - управление пакетами и зависимостями testing-xml - поддержка тестов для функций, которые возвращают xml rpc - реализация RPC для проекта apisite enfist - прикладная логика проекта enfist    3. Технические детали 3.1. Архитектура решения Исходим из того, что есть некое приложение, использующее БД и в этой БД есть информация 2х типов:\n оперативные данные, которые появляются в результате действий пользователей или администраторов приложения все остальное, что является результатом работы программистов (и должно храниться в git)  Решение может быть в том, чтобы первое положить в отдельные схемы БД, а схемы из п.2 при обновлении БД можно было удалять.\nСвязи между этими схемами, которые надо учитывать:\n Внешние ключи (некоторые справочники меняют только программисты, на них завязан код) Функции, которые возвращают значение по умолчанию  Эти связи регистрируются в специальных таблицах, что позволяет удалять их вместе с пакетами, восстанавливать при создании и все это производить в одной транзакции.\n3.2. Порядок работы Работа мигратора заключается в последовательном выполнении файлов, соответствующих маске, из заданных каталогов.\nФормат вызова:\n pgmig [options] init|test|drop|erase|reinit dir1[ dir2]... Для каждой команды задан список масок файлов:\n   Команда Маска Назначение     init *.sql Создание схемы и объектов БД   test *.test.sql Тесты для выполнения в init и отдельно    Команды, которые используют загруженный ранее код\n   Команда Функция Назначение     drop cleanup() удаление связей текущей схемы с другими схемами, удаление схемы пакета (если такой функции нет, схема БД будет удалена при вызове pkg_op_after())   erase cleanup(true) drop + удаление защищенных объектов из других схем (персистентных данных)    Команда reinit представляет собой последовательное выполнение drop, init в одной транзакции.\nКоманда update(TODO) аналогична init, но пропускаются пакеты с версией, совпадающей с уже загруженной в БД.\nПри выполнении init используются дополнительные группы файлов:\n   Группа Маска Назначение     new *.new.sql не выполняется, если пакет был создан ранее   once *.once.sql файл не выполняется повторно, пока не выполнен erase (если нет таких файлов, не будет проверки вызовом script_protected)    Сервисные функции SQL Вызывает pgmig\n pkg_version(pkg) - проверка существования пакета в БД pkg_op_before(op, pkg, version, repo) - операции перед выполнением заданной команды (для каждого пакета) pkg_op_after(op, pkg, version, repo) - операции после выполнения заданной команды (для каждого пакета) script_protected(pkg,file) - проверка регистрации файла однократного запуска script_protect(pkg,file,csum) - регистрация файла однократного запуска и его контрольной суммы  Используются в sql\n comment(type,code,comment...) - создание комментария к объекту БД assert_count(cnt) - указание количества тестов в текущем файле assert_eq() - тест - проверка на совпадение значений  Регистрация связей производится в файлах группы once при выполнении команды init.\nПример разделения файлов по префиксу    Префикс Имя Описание     0x init инициализация, проверка зависимостей от других пакетов   1x common функции, не имеющие зависимостей от объектов схемы   2x table.once создание таблиц в персистентных схемах (повторный вызов будет только после erase)   2x table.new создание таблиц и типов   3x view представления и функции для них   4x func основной код функций   4x func.test тесты функций   5x trig код триггеров   6x trig.new создание триггеров   7x data.new наполнение таблиц    Далее: В разработке\n4. История  Первая версия этой техники была реализована в 2010 как часть проекта PgWS Второе поколение - pomasql Эта документация описывает третье поколение  5. Авторы  Алексей Коврижкин - Идея и первичная реализация - LeKovr  См. Также список контрибьюторов, которые принимали участие в проекте.\n6. Лицензия Исходный код проектов pgmig публикуется под лицензией Apache 2.0 - см файл LICENSE.md.\n","description":"Документация версии v0.35","id":0,"section":"archive","tags":null,"title":"v0.35","uri":"https://pgmig.github.io/archive/v0.35/"},{"content":"pgmig - postgresql database migrations pgmig - это инструмент для управления изменениями схемы БД postgresql, который добавляет изменениям следующие возможности\n изменения выполняются в одной транзакции загрузкой исходного кода из файлов в алфавитном порядке их имен имена файлов с хранимым кодом и его тестами имеют заданную маску и они выполняются при любом изменении для отката от версии Б к версии А достаточно иметь содержимое БД (версии Б) и исходники версии А номер версии БД может определяется по git-атрибутам загружаемого исходного кода история изменений хранимого кода контролируется git  Варианты изменения схемы БД Обновление (up) Представляет собой загрузку в БД (выполнение) всех файлов с маской *.sql, которые не были загружены ранее или соответствуют маске --func_mask, в алфавитном порядке. В первом случае в БД сохраняется контрольная сумма файла и, если при будущем обновлении обнаружится изменение контрольной суммы файла на диске, будет выведено предупреждение. Также для каждого файла в БД сохраняется номер текущей версии.\n Корневой каталог для загружаемых файлов задается аргументом --dir. Подкаталоги просматриваются в алфавитном порядке Подкаталоги и файлы, имена которых начинаются с точки, игнорируются.  Откат (down) В терминах pgmig, откат означает отмену обновлений, сделанных после текущей версии, и представляет собой выполнение блоков отката для всех файлов с версией больше текущей (в обратном алфавитному порядке) и последующее выполнение всех файлов, которые соответствуют маске --func_mask, в алфавитном порядке.\nБлоки отката Размещаются в .sql файлах и содержат команды, отменяющие содержащиеся в них изменения схемы БД\nПо умолчанию блок отката имеет вид:\n1 2 3 4  SELECT pgmig.down($_$ drop index yy; drop table xx; $_$);   Такой вариант позволяет выполнить файл с помощью psql без изменений.\nДля совместимости с другими инструментами, поддерживается вариант, когда блок отката отделяется от основного кода разделителем, заданным в аргументе --down-delimiter. Содержимое файла после первого вхождения этого разделителя используется как аргумент в pgmig.down при выполнении обновления.\nПерезагрузка (реновация?) (reup (build?)) Повторная загрузка файлов текущей версии (если версия БД новее версии файлов, выполнение завершается с ошибкой).\nПредставляет собой выполнение блоков отката для всех файлов с именем, которое в алфавитном порядке идет после заданного аргументом --target (по умолчанию: 10_schema.sql) и последующее выполнение обновления.\nСпециальные значения аргумента --target\n last - выполняется только блок отката последнего файла all - блоки отката выполняются для всех файлов в каталоге reset - блоки отката выполняются для всех файлов в каталоге, обновление не выполняется  Другие команды  load - выполнить файлы, заданные --func-mask status - вывести список \u0026ldquo;пакет:версия\u0026rdquo; если пакетов \u0026gt;1 или просто версию пакета или отсутствие version - вывести версию pgmig  Версии БД При выполнении миграций используется номер текущей версии. Он может быть свой для каждого каталога и определяется аргументом --version\nСпециальные значения аргумента --version\n git - взять версию из .gitinfo (если есть) или метаданных git-репозитория (иначе) gitinfo - взять версию из .gitinfo prefix - взять версию из префикса файла  Если источником задан git, номер текущей версии берется из метаданных git-репозитория, которые могут быть привязаны к текущему каталогу или его предку.\nОпции  \u0026ndash;dir (каталог, где лежат пакеты, или сразу исходники если список пакетов пуст) \u0026ndash;verbose \u0026ndash;nocommit (exitstatus вернет наличие ошибок) \u0026ndash;json - форматировать вывод как список json  Дополнения Миграция прерывается при одном из условий\n после обработки всех файлов каталога зафиксирована ошибка в тестах при обработке файла зафиксирована иная ошибка  Вариант миграции может задаваться аргументом --cmd\nПеременные Перед загрузкой в БД файла или выполнением блока отката, в БД устанавливаются значения переменных\n pgmig.var_file() pgmig.var_path() pgmig.var_version()  Структура проекта pgmig  / - golang-пакет для встраивания в приложения /cmd/pgmig - приложение для управления изменениями (docker) /sql - SQL-код поддержки pgmig (поддерживает встраивание как pgmig/pgmigsql)  SQL-код поддержки pgmig  Дополнение БД сервисным хранимым кодом для документирования, тестов и разграничения доступа  Параллельные миграции В текущей версии параддельные миграции не поддерживаются. В начале работы ставится эксключивный лок до завершения\nЗапросы вне транзакций Если при выполнении миграции возникает необходимость выполнить действия вне транзакции (например CRATE INDEX CONCURRENTLY),\nделается так:\n register_extra_sql(sql) pgmig \u0026ndash;run-extra  Т.е. такие запросы собираются в отдельный буфер и потом могут быть выполнены или сразу после успешного выполнения миграции или отдельным вызовом pgmig\nПараллельные миграции\n","description":"Какие задачи решает проект","id":1,"section":"docs","tags":null,"title":"Назначение","uri":"https://pgmig.github.io/docs/intro/"},{"content":"PgMig. FAQ 1. Каково назначение проекта? Для баз данных СУБД Postgresql организовать размещение DDL запросов в файлах под контролем СКВ с гарантией соответствия этих файлов содержимому БД.\n2. Как организован DDL?  DDL размещается в файлах и загружается из них в БД Файлы разбиты на папки, каждая папка - весь DDL некоторой схемы БД  3. Как производится обновление кода в БД? Обновление заданной схемы БД:\n Из git получаем исходники нужной версии Начинаем транзакцию В БД удаляем схему данных Загружаем в БД исходники схемы Завершаем транзакцию  4. Как быть с изменяемыми в процессе работы данными? Таблицы с такими данным (далее - оперативными данными) размещаются в отдельных схемах БД и не удаляются при обновлении. В этих схемах размещаются только такие таблицы и используемые в них типы.\n5. Как быть с зависимостями оперативных данных? У таблиц оперативных данных может быть два вида зависимостей:\n внешние ключи значения по умолчанию  Эти зависимости при создании регистрируются в служебных таблицах и удаляются перед удалением связанной схемы\n6. Как быть с зависимостями от других схем БД? Если в проекте есть схемы А и В, при этом схема В использует что-то из А, то схема В\n должна создаваться после схемы А должна удаляться перед схемой А  Из этого следует, что схемы не должны иметь циклических зависимостей\n7. Как тестировать изменения? Для тестирования можно использовать служебные функции, которые сравнивают результат запроса с эталоном и, при несовпадении\n выводят отличия (чтобы результат было удобно использовать в качестве эталона) генерируют ошибку (это позволяет не сделать COMMIT по завершении)  Если в начале каждого теста выполнить SAVEPOINT, по завершении - ROLLBACK TO SAVEPOINT, то будут выполнены все тесты независимо от результата каждого из них (кроме этого, тесты не будут мешать друг другу)\n8. Можно ли обновить код хранимых функций, ничего не удаляя? В случае если\n функции создаются конструкцией вида CREATE OR REPLACE FUNCTION файлы, в которых размещены функции, содержат только их  всегда есть возможность выполнить этот файл (в т.ч. с помощью psql).\nБолее удобным может оказаться обновление в рамках инструкции \u0026ldquo;обновить код всех функций, прогнать тесты и сделать commit в случае отсутствия ошибок\u0026rdquo;. Для этого в pgmig предназначена отдельная команда\n9. Как менять структуру оперативных данных? Т.к. схемы с оперативными данными не удаляются, изменения в них - это операции, которые в каждой БД должны выполниться однократно. Это можно реализовать так:\n изменения помещать в файлы с заданной маской имени (например - *_once.sql) в служебной таблице БД хранить имен загруженных файлов при попытке загрузить файл, который уже зарегистрирован - ничего не делать  ","description":"FAQ версии v0.35","id":2,"section":"archive","tags":null,"title":"v0.35 FAQ","uri":"https://pgmig.github.io/archive/v0.35-faq/"},{"content":"   PgMig (en)  PgMig  Архивные версии (en)  v0.35 FAQ  v0.35 (en)  Документация  Назначение  Список страниц (en)  ","description":"Docker powered servers","id":4,"section":"","tags":null,"title":"Список страниц","uri":"https://pgmig.github.io/map/"}]