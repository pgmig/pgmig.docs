[{"content":"pgmig Разработка и сопровождение приложений в СУБД postgresql\n1. Переводы Этот сайт доступен на следующих языках:\nАнглийский (черновик) Русский (до релиза 1.0 - наиболее полное описание) 2. Описание pgmig - это утилита и библиотека для загрузки в БД postgresql файлов *.sql из клонированного git-репозитория (или нескольких) и последующей загрузки изменений этих файлов.\nВ проекте реализовано два способа изменения (миграции) БД:\nЗагрузка только файлов с идемпотентными запросами (например, CREATE OR REPLACE FUNCTION при отсутствии изменений в сигнатуре) Загрузка всех файлов схемы БД с ее предварительным удалением Проект решает следующие задачи:\nСинхронизировать исходники в git и содержимое БД в части, которая не меняется в процессе эксплуатации (структура данных, представления, индексы, функции, триггеры, справочники и т.п.) Реализовать механизм тестирования хранимого кода Изменять БД только при успешном прохождении тестов Для решения этих задач приняты следующие правила:\nВсе, что загружается в БД, разбито на пакеты (схемы) Все, что меняется в процессе эксплуатации приложения, выносится в отдельные схемы БД (далее - оперативные данные) Чтобы гарантировать соответствие кода в git схемам неоперативных данных, перед обновлением они удаляются Весь SQL-код разделяется на файлы так, чтобы любое изменение БД можно было описать маской имен файлов, которые должны быть для него выполнены 2.1. Состав проекта pgmig - встраиваемая библиотека и утилита для миграции (golang) pgmig.perl - порт pgmig на perl SQL-пакеты: pgmig - управление пакетами и зависимостями testing-xml - поддержка тестов для функций, которые возвращают xml rpc - реализация RPC для проекта apisite enfist - прикладная логика проекта enfist 3. Технические детали 3.1. Архитектура решения Исходим из того, что есть некое приложение, использующее БД и в этой БД есть информация 2х типов:\nоперативные данные, которые появляются в результате действий пользователей или администраторов приложения все остальное, что является результатом работы программистов (и должно храниться в git) Решение может быть в том, чтобы первое положить в отдельные схемы БД, а схемы из п.2 при обновлении БД можно было удалять.\nСвязи между этими схемами, которые надо учитывать:\nВнешние ключи (некоторые справочники меняют только программисты, на них завязан код) Функции, которые возвращают значение по умолчанию Эти связи регистрируются в специальных таблицах, что позволяет удалять их вместе с пакетами, восстанавливать при создании и все это производить в одной транзакции.\n3.2. Порядок работы Работа мигратора заключается в последовательном выполнении файлов, соответствующих маске, из заданных каталогов.\nФормат вызова:\npgmig [options] init|test|drop|erase|reinit dir1[ dir2]... Для каждой команды задан список масок файлов:\nКоманда Маска Назначение init *.sql Создание схемы и объектов БД test *.test.sql Тесты для выполнения в init и отдельно Команды, которые используют загруженный ранее код\nКоманда Функция Назначение drop cleanup() удаление связей текущей схемы с другими схемами, удаление схемы пакета (если такой функции нет, схема БД будет удалена при вызове pkg_op_after()) erase cleanup(true) drop + удаление защищенных объектов из других схем (персистентных данных) Команда reinit представляет собой последовательное выполнение drop, init в одной транзакции.\nКоманда update(TODO) аналогична init, но пропускаются пакеты с версией, совпадающей с уже загруженной в БД.\nПри выполнении init используются дополнительные группы файлов:\nГруппа Маска Назначение new *.new.sql не выполняется, если пакет был создан ранее once *.once.sql файл не выполняется повторно, пока не выполнен erase (если нет таких файлов, не будет проверки вызовом script_protected) Сервисные функции SQL Вызывает pgmig\npkg_version(pkg) - проверка существования пакета в БД pkg_op_before(op, pkg, version, repo) - операции перед выполнением заданной команды (для каждого пакета) pkg_op_after(op, pkg, version, repo) - операции после выполнения заданной команды (для каждого пакета) script_protected(pkg,file) - проверка регистрации файла однократного запуска script_protect(pkg,file,csum) - регистрация файла однократного запуска и его контрольной суммы Используются в sql\ncomment(type,code,comment...) - создание комментария к объекту БД assert_count(cnt) - указание количества тестов в текущем файле assert_eq() - тест - проверка на совпадение значений Регистрация связей производится в файлах группы once при выполнении команды init.\nПример разделения файлов по префиксу Префикс Имя Описание 0x init инициализация, проверка зависимостей от других пакетов 1x common функции, не имеющие зависимостей от объектов схемы 2x table.once создание таблиц в персистентных схемах (повторный вызов будет только после erase) 2x table.new создание таблиц и типов 3x view представления и функции для них 4x func основной код функций 4x func.test тесты функций 5x trig код триггеров 6x trig.new создание триггеров 7x data.new наполнение таблиц Далее: В разработке\n4. История Первая версия этой техники была реализована в 2010 как часть проекта PgWS Второе поколение - pomasql Эта документация описывает третье поколение 5. Авторы Алексей Коврижкин - Идея и первичная реализация - LeKovr См. Также список контрибьюторов, которые принимали участие в проекте.\n6. Лицензия Исходный код проектов pgmig публикуется под лицензией Apache 2.0 - см файл LICENSE.md.\n","description":"Документация версии v0.35","id":0,"section":"archive","tags":null,"title":"v0.35","uri":"https://pgmig.github.io/archive/v0.35/"},{"content":"pgmig - postgresql database migrations pgmig - это инструмент для управления изменениями схемы БД postgresql, который добавляет изменениям следующие возможности\nизменения выполняются в одной транзакции загрузкой исходного кода из файлов в алфавитном порядке их имен имена файлов с хранимым кодом и его тестами имеют заданную маску и они выполняются при любом изменении для отката от версии Б к версии А достаточно иметь содержимое БД (версии Б) и исходники версии А номер версии БД определяется по git-атрибутам загружаемого исходного кода история изменений схемы данных и хранимого кода контролируется git Варианты изменения схемы БД Обновление (up) Загрузка в БД изменений и компиляция хранимого кода.\nВ корневом каталоге и каждом подкаталоге, для каждого файла с маской *.sql\nесли соответствует маске --code_mask - загрузить иначе - проверить наличие файла в БД если нет - загрузить и сохранить в БД контрольную сумму если контрольная сумма совпадает - пропустить иначе - прекратить работу с ошибкой Дополнения\nкроме контрольной суммы, для каждого файла в БД сохраняется номер текущей версии каталога (по данным git). корневой каталог для загружаемых файлов задается аргументом --dir. подкаталоги и файлы просматриваются в алфавитном порядке подкаталоги и файлы, имена которых начинаются с точки, игнорируются. если задан аргумент --down-delimiter, часть файла, идущая после его значения, не выполняется, а используется как аргумент функции pgmig.down (для совместимости с goose) Откат (down) В терминах pgmig, откат означает отмену обновлений, сделанных после текущей версии, и выполняется так:\nдля всех загруженных в БД файлов с версией больше текущей (в обратном алфавитному порядке) выполнить блок отката по завершении обработки каталога выполнить все соответствующие ему файлы по маске --code_mask Блоки отката Размещаются в .sql файлах и содержат команды, отменяющие содержащиеся в них изменения схемы БД.\nПример блока отката:\n1 2 3 4 SELECT pgmig.down($_$ drop index yy; drop table xx; $_$); Такой вариант позволяет выполнить файл с помощью psql без изменений.\nЗагрузка текущей версии (build) Команда представляет собой обновление до текущей версии с её предварительным откатом, предназначена для поддержки процесса разработки и включает следующее:\nвыполнить блоки отката для всех файлов с именем, которое в алфавитном порядке идет после заданного аргументом --target (по умолчанию: 10_schema.sql) выполненить обновление. Дополнения\nесли версия БД новее версии файлов, выполнение завершается с ошибкой специальные значения аргумента --target last - выполняется только блок отката последнего файла all - блоки отката выполняются для всех файлов в каталоге reset - блоки отката выполняются для всех файлов в каталоге, обновление не выполняется Другие команды code - выполнить файлы, заданные --code-mask status - вывести реестр загруженных в БД файлов version - вывести версию pgmig Опции --cmd - команда миграции (если не задано иначе) --dir - каталог, где лежат пакеты --pkg - список пакетов (если не задано - совпадает со списком подкаталогов) --exclude - список игнорируемых пакетов --code_mask - шаблон имени файла с кодом (по умолчанию: *.code.sql) --down-delimiter - разделитель для блока отката --target - целевой файл отката для команды build --version - источник версии файлов в каталоге --verbose - выводить отладочную информацию --nocommit - не выполнять коммит по завершении (exitstatus вернет наличие ошибок) --json - форматировать вывод как список json Переменные Перед загрузкой файла в БД и перед выполнением блока отката, в БД устанавливаются значения переменных, доступные через вызовы функций:\npgmig.var_file() - имя файла pgmig.var_path() - путь к файлу pgmig.var_version() - версия каталога Дополнения Код возврата Миграция прерывается при одном из условий\n01 - ошибка в параметрах конфигурации 02 - команда не входит в число поддерживаемых 03 - команда не входит в число поддерживаемых 04 - после обработки всех файлов каталога зафиксирована ошибка в тестах 05 - при обработке файла зафиксирована ошибка выполнения SQL 06 - попытка выполнить build при версии БД больше текущей Версии БД При выполнении миграций используется номер текущей версии. Он может быть свой для каждого каталога и определяется аргументом --version\nСпециальные значения аргумента --version\ngit - взять версию из .gitinfo (если есть) или метаданных git-репозитория (иначе) gitinfo - взять версию из .gitinfo prefix - взять версию из префикса файла Если источником задан git, номер текущей версии берется из метаданных git-репозитория, которые могут быть привязаны к текущему каталогу или его предку.\nSQL-код поддержки pgmig Дополнение БД сервисным хранимым кодом для документирования, тестов и разграничения доступа\npgmig.down - регистрация блока отката\npgmig.extra - регистрация запросов вне транзакций\nЗапросы вне транзакций Если при выполнении миграции возникает необходимость выполнить SQL-запросы вне транзакции (например CREATE INDEX CONCURRENTLY), код этих запросов регистрируется при обновлении вызовом pgmig.extra(sql) и выполняется в отдельной горутине после выполнения COMMIT.\nПараллельные миграции В текущей версии параддельные миграции не поддерживаются. В начале работы ставится эксключивный лок до завершения\nСтруктура проекта pgmig / - golang-пакет для встраивания в приложения /cmd/pgmig - приложение для управления изменениями (docker) /sql - SQL-код поддержки pgmig (поддерживает встраивание как pgmig/pgmigsql) ","description":"Какие задачи решает проект","id":1,"section":"docs","tags":null,"title":"Назначение","uri":"https://pgmig.github.io/docs/intro/"},{"content":"PgMig. FAQ 1. Каково назначение проекта? Для баз данных СУБД Postgresql организовать размещение DDL запросов в файлах под контролем СКВ с гарантией соответствия этих файлов содержимому БД.\n2. Как организован DDL? DDL размещается в файлах и загружается из них в БД Файлы разбиты на папки, каждая папка - весь DDL некоторой схемы БД 3. Как производится обновление кода в БД? Обновление заданной схемы БД:\nИз git получаем исходники нужной версии Начинаем транзакцию В БД удаляем схему данных Загружаем в БД исходники схемы Завершаем транзакцию 4. Как быть с изменяемыми в процессе работы данными? Таблицы с такими данным (далее - оперативными данными) размещаются в отдельных схемах БД и не удаляются при обновлении. В этих схемах размещаются только такие таблицы и используемые в них типы.\n5. Как быть с зависимостями оперативных данных? У таблиц оперативных данных может быть два вида зависимостей:\nвнешние ключи значения по умолчанию Эти зависимости при создании регистрируются в служебных таблицах и удаляются перед удалением связанной схемы\n6. Как быть с зависимостями от других схем БД? Если в проекте есть схемы А и В, при этом схема В использует что-то из А, то схема В\nдолжна создаваться после схемы А должна удаляться перед схемой А Из этого следует, что схемы не должны иметь циклических зависимостей\n7. Как тестировать изменения? Для тестирования можно использовать служебные функции, которые сравнивают результат запроса с эталоном и, при несовпадении\nвыводят отличия (чтобы результат было удобно использовать в качестве эталона) генерируют ошибку (это позволяет не сделать COMMIT по завершении) Если в начале каждого теста выполнить SAVEPOINT, по завершении - ROLLBACK TO SAVEPOINT, то будут выполнены все тесты независимо от результата каждого из них (кроме этого, тесты не будут мешать друг другу)\n8. Можно ли обновить код хранимых функций, ничего не удаляя? В случае если\nфункции создаются конструкцией вида CREATE OR REPLACE FUNCTION файлы, в которых размещены функции, содержат только их всегда есть возможность выполнить этот файл (в т.ч. с помощью psql).\nБолее удобным может оказаться обновление в рамках инструкции \u0026ldquo;обновить код всех функций, прогнать тесты и сделать commit в случае отсутствия ошибок\u0026rdquo;. Для этого в pgmig предназначена отдельная команда\n9. Как менять структуру оперативных данных? Т.к. схемы с оперативными данными не удаляются, изменения в них - это операции, которые в каждой БД должны выполниться однократно. Это можно реализовать так:\nизменения помещать в файлы с заданной маской имени (например - *_once.sql) в служебной таблице БД хранить имен загруженных файлов при попытке загрузить файл, который уже зарегистрирован - ничего не делать ","description":"FAQ версии v0.35","id":2,"section":"archive","tags":null,"title":"v0.35 FAQ","uri":"https://pgmig.github.io/archive/v0.35-faq/"},{"content":" PgMig (en) PgMig Архивные версии (en) v0.35 FAQ v0.35 (en) Документация Назначение Список страниц (en) ","description":"Docker powered servers","id":4,"section":"","tags":null,"title":"Список страниц","uri":"https://pgmig.github.io/map/"}]